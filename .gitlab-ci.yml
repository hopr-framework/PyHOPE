# -*- coding: utf-8 -*-
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of PyHOPE
#
# Copyright (c) 2024 Numerics Research Group, University of Stuttgart, Prof. Andrea Beck
#
# PyHOPE is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# PyHOPE is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# PyHOPE. If not, see <http://www.gnu.org/licenses/>.

# ==================================================================================================================================
# Continuous Integration/Continuous Deployment
# ==================================================================================================================================

# Official language image. Look for the different tagged releases at:
# > https://hub.docker.com/r/library/python/tags/
image: python:latest

# Change pip's cache directory to be inside the project directory since we can only cache local items.
variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"

# https://pip.pypa.io/en/stable/topics/caching/
cache:
  paths:
    - venv
    - .cache/pip

# ----------------------------------------------------------------------------------------------------------------------------------------------------
# Templates ("hidden jobs")
# ----------------------------------------------------------------------------------------------------------------------------------------------------
.defaults: &defaults
  tags: [dockertag]

.defaults_coverage: &defaults_coverage
  <<: *defaults
  artifacts:
    paths:
      - coverage.xml
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

# ----------------------------------------------------------------------------------------------------------------------------------------------------
# Setup
# ----------------------------------------------------------------------------------------------------------------------------------------------------

# Define a reusable global before_script with YAML anchors
.global-before-script: &global-before-script
  - ulimit -s unlimited
  - module list || true
  - python3 --version
  # Setup required packages
  - | # Literal YAML multiline block scalar indicator
    if command -v apt-get >/dev/null 2>&1; then
      apt-get update
      apt-get install -y libglu1-mesa-dev freeglut3-dev mesa-common-dev libxcursor1 libxinerama1
    fi
  - | # Literal YAML multiline block scalar indicator
    if command -v dnf >/dev/null 2>&1; then
      dnf makecache
      dnf install -y mesa-libGLU-devel freeglut-devel libXcursor libXinerama
    fi
  # Setup Python pip
  - python3 -m pip install --upgrade pip --root-user-action=ignore || true
  - python3 -m pip --version
  # Setup Python virtual environment
  - rm -rf venv
  - python3 -m venv venv
  - source venv/bin/activate
  # # Cleanup previous installs
  # - pip freeze | xargs pip uninstall -y --root-user-action=ignore
  # Install all pre-requisites
  - pip install --no-cache-dir -e . --root-user-action=ignore
  # Regression checks needs NRG Gmsh
  - pip uninstall -y gmsh --root-user-action=ignore
  - pip install --no-cache-dir https://gitlab.iag.uni-stuttgart.de/libs/python-gmsh/-/raw/master/gmsh-4.13.1-py3-none-linux_x86_64.whl --root-user-action=ignore
  # Install coverage
  - pip install --no-cache-dir coverage --root-user-action=ignore

before_script: *global-before-script

# ----------------------------------------------------------------------------------------------------------------------------------------------------
# Stages
# ----------------------------------------------------------------------------------------------------------------------------------------------------
stages:
  - lint
  - coverage
  - convergence

# ----------------------------------------------------------------------------------------------------------------------------------------------------
# Linter
# ----------------------------------------------------------------------------------------------------------------------------------------------------
ruff:
  extends: .defaults
  stage: lint
  script:
    - python3 -m pip install ruff
    - ruff --version
    - ruff check --extend-ignore=E201,E202,E203,E221,E222,E225,E231,E271,E272 --line-length=132 --preview pyhope/

# ----------------------------------------------------------------------------------------------------------------------------------------------------
# Reggie
# ----------------------------------------------------------------------------------------------------------------------------------------------------
coverage:
  extends: .defaults_coverage
  stage: coverage
  script:
    # Store the base directory
    - basedir=$(pwd)

    # Define colors for PASS/FAIL output
    - green="\033[32m"
    - red="\033[31m"
    - reset="\033[0m"

    # Initialize an array for storing results (directory and pass/fail status)
    - declare -a results

    # Store all directories with "parameter.ini" files in an array (bash-only)
    - mapfile -d '' paramfiles < <(find tutorials -type f -name "parameter.ini" -print0)
    - echo "Found "${#paramfiles[@]}" parameter.ini files..."

    # Calculate max width
    - max_dir_length=0
    - | # Literal YAML multiline block scalar indicator
      for paramfile in "${paramfiles[@]}"; do
        paramdir=$(dirname "$paramfile")
        paramlen=${#paramdir}

        if [ "$paramlen" -gt "$max_dir_length" ]; then
          max_dir_length=$paramlen
        fi
      done
    - box_width=$((max_dir_length + 10))  # Add padding for aesthetics
    - col_width=$((max_dir_length + 2))   # Add padding for the table

    # Iterate over all directories, run tests, and collect results
    - echo "Running PyHOPE with coverage for each parameter.ini file..."

    - | # Literal YAML multiline block scalar indicator
      for paramfile in "${paramfiles[@]}"; do
        paramdir=$(dirname  "$paramfile")
        paramstr=$(basename "$paramdir" )
        paramini=$(basename "$paramfile")

        # Print a message for the running task
        echo ""
        printf "┌─%s─┐\n" "$(printf '─%.0s' $(seq 1 $((box_width))))"
        printf "│ Running %-$(($box_width-8))s │\n" "$paramdir"
        printf "└─%s─┘\n" "$(printf '─%.0s' $(seq 1 $((box_width))))"

        # Change directory to where the parameter.ini file is located, suppress output
        pushd "$paramdir" > /dev/null

        # Run the script under coverage and capture the result
        if coverage run --data-file="$basedir/.coverage.$paramstr" --source="$basedir" -m pyhope "$paramini"; then
          results+=("$paramdir: PASS")
          echo -e "${green}✔ PASS${reset}: $paramini"
        else
          results+=("$paramdir: FAIL")
          echo -e "${red}✖ FAIL${reset}: $paramini"
        fi

        # Return to the previous directory, suppress output
        popd > /dev/null
      done

    # Combine coverage reports from all example directories
    - echo "Combining coverage reports..."
    - coverage combine

    # Generate the coverage report in XML format
    - echo "Generating coverage report..."
    - coverage xml
    - coverage report --skip-empty

    # Output the final sorted report as a UTF-8 box-drawing table
    - | # Literal YAML multiline block scalar indicator
      echo ""
      printf "┌─%s─┬────────┐\n" "$(printf '─%.0s' $(seq 1 $((max_dir_length))))"
      printf "│ %-$(($col_width-2))s │ %-5s │\n" "Example Directory" "Result"
      printf "├─%s─┼────────┤\n" "$(printf '─%.0s' $(seq 1 $((max_dir_length))))"
      for result in "${results[@]}"; do
        paramdir=$(echo "$result" | cut -d ':' -f 1)
        paramres=$(echo "$result" | cut -d ':' -f 2 | tr -d '[:space:]')

        if [[ "$paramres" == "PASS" ]]; then
          printf "│ %-$(($col_width-2))s │ ${green}%-6s${reset} │\n" "$paramdir" "$paramres"
        else
          printf "│ %-$(($col_width-2))s │ ${red}%-6s${reset} │\n" "$paramdir" "$paramres"
        fi
      done
      printf "└─%s─┴────────┘\n" "$(printf '─%.0s' $(seq 1 $((max_dir_length))))"

    # Fail the job if any examples failed
    - | # Literal YAML multiline block scalar indicator
      if [[ "${results[*]}" == *"FAIL"* ]]; then
        echo "Some examples failed.";
        exit 1;
      else
        echo "All examples passed.";
      fi

# ----------------------------------------------------------------------------------------------------------------------------------------------------
# FLEXI convergence tests
# ----------------------------------------------------------------------------------------------------------------------------------------------------
convergence:
  extends: .defaults
  stage: convergence
  image: fedora:latest
  artifacts:
    paths:
      - convergence.log
  before_script:
    # Install FLEXI dependencies
    - | # Literal YAML multiline block scalar indicator
      if command -v dnf >/dev/null 2>&1; then
        dnf makecache
        dnf install -y  git cmake gcc-c++ gcc-gfortran mpich-devel zlib-ng-devel openblas-devel hdf5-mpich-devel
        source /etc/profile
        module load mpi
        dnf install -y python3 python3-pip python3-virtualenv
      fi
    - | # Literal YAML multiline block scalar indicator
      if command -v apt-get >/dev/null 2>&1; then
        apt-get update
        apt-get install -y git cmake-extras g++ gfortran mpi-default-dev zlib1g-dev libopenblas-dev libhdf5-mpi-dev
        apt-get install -y python3 python3-pip python3-venv
        apt-get install -y libxft2 libxext6
      fi
    # Reuse global before_script to avoid duplicate code for python
    - *global-before-script
    # Install FLEXI
    - rm -rf flexi
    - git clone --branch master --single-branch --depth 1 https://github.com/flexi-framework/flexi.git
    - cd flexi
    - cmake -B build
    - cmake --build build
    - FLEXIDIR=$(pwd)
    - cd ..
  script:
    # Generate Meshes
    - rm -rf convergence_test
    - mkdir convergence_test
    - cd convergence_test
    - cp ../tutorials/5-02-convtest_flipped/parameter_FLIPPED_template_pyhope.ini .
    - cp ../tutorials/5-02-convtest_flipped/parameter_flexi.ini .
    # Generate Meshes
    - meshres=("001" "002" "004" "008")
    - template_file="parameter_FLIPPED_template_pyhope.ini"
    - | # Literal YAML multiline block scalar indicator
      for res in "${meshres[@]}"; do
        # Calculate nElem2 as half the integer res of nElem
        nElem2=$((10#$res / 2)) # Use 10#$res to interpret value as a base-10 integer
        # Create a temporary parameter file
        temp_file=$(mktemp)
        # Replace placeholders in the template and save to the temporary file
        sed -e "s/<nElem>/$res/g" -e "s/<nElem2>/$nElem2/g" "$template_file" > "$temp_file"
        # Build the mesh
        pyhope "$temp_file"
        # Clean up the temporary file
        rm "$temp_file"
      done
    # Call convergence script
    - echo "=== Running Convergence Test  N=1 ===" | tee ../convergence.log
    - python3 $FLEXIDIR/tools/convergence_test/convergence_grid --N 1 --dim 3 --procs 1 $FLEXIDIR/build/bin/flexi parameter_flexi.ini | tee -a ../convergence.log
    - echo "=== Running Convergence Test  N=2 ===" | tee -a ../convergence.log
    - python3 $FLEXIDIR/tools/convergence_test/convergence_grid --N 2 --dim 3 --procs 1 $FLEXIDIR/build/bin/flexi parameter_flexi.ini | tee -a ../convergence.log
    - echo "=== Running Convergence Test  N=3 ===" | tee -a ../convergence.log
    - python3 $FLEXIDIR/tools/convergence_test/convergence_grid --N 3 --dim 3 --procs 1 $FLEXIDIR/build/bin/flexi parameter_flexi.ini | tee -a ../convergence.log
    - echo "=== Running Convergence Test  N=4 ===" | tee -a ../convergence.log
    - python3 $FLEXIDIR/tools/convergence_test/convergence_grid --N 4 --dim 3 --procs 1 $FLEXIDIR/build/bin/flexi parameter_flexi.ini | tee -a ../convergence.log
    # Analyze convergence behavior using a simple python script
    - cd ..
    - |
      python3 << 'EOF' # collapsed multi-line command
      import sys

      # Input file
      convfile = "convergence.log"

      # Set tolerance bounds: (N+1)+-0.35
      def compute_expected_range(N):
          return N + 0.65, N + 1.35

      # Process the results
      def process_results(degree, data):
          min_eoc, max_eoc = compute_expected_range(degree)
          print(f"Checking EOCs for Polynomial Degree N={degree} (Expected: [{min_eoc}, {max_eoc}])")
          results = []
          for idx, (grid, eoc) in enumerate(data[1:]):
              passed = min_eoc <= eoc <= max_eoc
              results.append((grid, min_eoc, max_eoc, eoc, "PASS" if passed else ("(PASS)" if idx < len(data) - 2 else "FAIL")))
          draw_table(results)
          return all(r[4] == "PASS" for r in results[-1:])

      # Draw the results as a table
      def draw_table(results):
          print("\n┌───────┬─────────┬─────────┬─────────┬────────┐")
          print("│ Mesh  │   min   │   max   │  result │ Passed │")
          print("├───────┼─────────┼─────────┼─────────┼────────┤")
          for grid, min_eoc, max_eoc, result, passed in results:
              pass_col = ( "\033[92m PASS \033[0m" if passed == "PASS" else ("\033[93m(PASS)\033[0m" if passed == "(PASS)" else "\033[91m FAIL \033[0m"))
              print(f"│ {grid:^5} │ {min_eoc:^7.2f} │ {max_eoc:^7.2f} │ {result:^7.2f} │ {pass_col:^6} │")
          print("└───────┴─────────┴─────────┴─────────┴────────┘\n")

      # Parse the log file
      try:
          with open(convfile, "r") as f:
              lines = f.readlines()
      except FileNotFoundError:
          sys.exit(f"Error: File '{convfile}' not found.")

      # Process the file
      success, current_degree, current_data = True, None, []

      for line in lines:
          line = line.strip()
          # Match polynomial degree header
          if line.startswith("=== Running Convergence Test") and "N=" in line:
              if current_degree is not None:
                  success &= process_results(current_degree, current_data)
              try:
                  current_degree = int(line.split("N=")[1].split()[0])
              except ValueError:
                  current_degree = None
              current_data = []
          # Match grid data rows
          elif current_degree is not None and "║" in line:
              try:
                  grid, eoc = int(line.split("║")[0].strip()), float(line.split("║")[2].strip())
                  current_data.append((grid, eoc))
              except ValueError:
                  pass

      # Final status
      sys.exit(0 if success else print("Some EOCs are out of range.") or 1)
      EOF
